## How Are Best Practices Relevant in Software Engineering?
1. Enhance Code Readability
2. Ensure Your Code Works Efficiently
3. Refactor Your Code
4. Develop A Professional Coding Style
5. Use Version Control
6. Test Your Code
7. The KISS Principle
8. The YAGNI Principle
9. The DRY Principle

## REST API Design Best Practices
1. Use JSON as the Format for Sending and Receiving Data
2. Use Nouns Instead of Verbs in Endpoints
3. Name Collections with Plural Nouns
4. Use Status Codes in Error Handling
5. Use Nesting on Endpoints to Show Relationships
6. Use Filtering, Sorting, and Pagination to Retrieve the Data Requested
7. Use SSL for Security
8. Be Clear with Versioning
9. Provide Accurate API Documentation

## Plan for tradeoffs: You can’t optimize all software quality attributes
[resource](https://stackoverflow.blog/2022/01/17/plan-for-tradeoffs-you-cant-optimize-all-software-quality-attributes/)
#### Some important quality attributes for software systems
1. `Availability`	Can I use the system when and where I need to?
2. `Conformance` to standards 	Does the system comply with all applicable standards for functionality, safety, communication, certification, and interfaces?
3. `Efficiency`	Does the system use computer resources economically?
4. `Installability`	Can I easily install, uninstall, and reinstall the system and upgrades?
5. `Integrity`	Does the system protect against data inaccuracy, corruption, and loss?
6. `Interoperability`	Does the system connect well with others to exchange data and services?
7. `Maintainability`	Can developers easily modify, correct, and enhance the system?
8. `Performance`	Does the system respond sufficiently quickly to user actions and external events?
9. `Portability`	Can the system be migrated to different platforms easily?
10. `Reliability`	Does the system run when it’s supposed to without failing?
11. `Reusability`	Can developers reuse portions of the system in other products?
12. `Robustness`	Does the system respond sensibly to erroneous inputs and unexpected operating conditions?
13. `Safety`	Does the system protect users from harm and property from damage?
14. `Scalability`	Can the system easily expand to accommodate more users, data, or transactions?
15. `Security`	Does the system protect against malware attacks, intruders, unauthorized users, and data theft?
16. `Usability`	Can users easily learn how to use the system to accomplish their tasks?
17. `Verifiability`	Can testers determine whether the software was implemented correctly?

#### Some additional quality attributes for physical products containing embedded software
1. `Durability`	Will the product hold up well under normal usage conditions?
2. `Extensibility`	Can new functionality, sensors, or other hardware be added easily to the product without disrupting its functioning?
3. `Fault handling`	Does the product detect, recover from, and log faults that occur?
4. `Manufacturability`	Is the product easy and cost-effective to manufacture?
5. `Resource usage`	Does the product retain enough slack capacity in the resources consumed for memory, network bandwidth, power, processor capacity, and so forth?
6. `Serviceability`	Can people efficiently perform preventive and corrective maintenance on the product?
7. `Sustainability`	Does the product have minimum adverse environmental impacts over its lifecycle, from extraction of raw materials to manufacturing, usage, and disposal?
8. `Upgradability`	Can the product easily be enhanced by adding or replacing components?

## The four engineering metrics that will streamline your software delivery
[resource](https://stackoverflow.blog/2021/11/29/the-four-engineering-metrics-that-will-streamline-your-software-delivery/)
1. Deployment frequency
2. Mean change lead time
3. Mean time to restore
4. Change failure rate

## Code quality: a concern for businesses, bottom lines, and empathetic programmers
[resource](https://stackoverflow.blog/2021/10/18/code-quality-a-concern-for-businesses-bottom-lines-and-empathetic-programmers/)
#### A few of the most important factors in code quality are:
1. Encapsulation
2. Meaningful names
3. Low cyclomatic complexity
4. Idiomatic code
